STAR

（什么情况下）



Q&A

描述下是怎么实现限速器的？调用方线程是怎么实现阻塞的？

对外提供的api有

```java
    // 获取资源
		public String aquire(){}
		// 释放资源
		public void release(String taskId){}

```

限速器关注的点有2个：

1. 当前在跑的任务
2. 当前时间段所剩的资源数

为了能在集群环境下的正常使用。Ratelimter使用分布式锁redisson Lock保护同步段，在同步段内判断资源是否满足条件，如果不满足条件，当前线程先sleep一段时间后，在判断条件是否满足。



使用的redis数据结构有 Hash 和string

hash里面维护着再跑的任务

string用来维护任务的过期时间



为了防止调用方不释放资源，设置一个任务保留时间，默认5分钟。



sleep是不会释放锁资源的。



redisson lock是怎么造成调用方阻塞。redisson的api中获得一个future。然后调用future.get()阻塞调用方线程，等待结果返回。

怎么避免mq出现消息丢失和消息重复消费的问题呢？
消息丢失

S：**跨网络就肯定会有丢消息的可能。**

1. 消息生产方produce发送消息给broker
2. Broker主从同步
3. broker发送消息至consumer

T：

​	1.如何确保produce发送至broker

​		rocketmq producer提供了多种发送方式，同步发送、异步发送、单向发送。

​		produce想要发送消息不丢失，可以采用同步发送的方式去发消息，send消息方法只要不抛出异常，就代表发送成功。发送成功会有多个状态，以下对每个状态进行说明：

- **SEND_OK**：消息发送成功，Broker刷盘、主从同步成功

- FLUSH_DISK_TIMEOUT：消息发送成功，但是服务器同步刷盘（默认为异步刷盘）超时

- FLUSH_SLAVE_TIMEOUT：消息发送成功，但是服务器同步复制（默认为异步复制）到Slave时超时（默认超时时间5秒）

- SLAVE_NOT_AVAILABLE：Broker从节点不存在

  

  注意：同步发送只要返回以上四种状态，就代表该消息在生产阶段消息正确的投递到了RocketMq，没有丢失。但也只是消息投递过程没有丢失，并不代表存储阶段消息不丢失，当出现超时或失败状态时，则会触发默认的2次重试。从生产者角度看，如果消息未能正常的存储在MQ，或者消费者未能正确的消费这条消息，都是消息丢失。	

  **如果业务要求严格，为保证消息的成功投递和保存，我们可以只取SEND_OK标识消息发送成功，把失败的消息记录到数据库，并启动一个定时任务，扫描发送失败的消息，重试发送5次，直到成功或者发送5次后通知钉钉或邮件通知人工处理**

A：生产方使用同步发送



消费方

roketmq保证每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才会向服务器方会ack，如果没有消费一定不会ack消息。所以RocketMQ可以确保消费方消息不丢失。



有没有了解过rocketmq 顺序消息是怎么实现的

在MQ模型中，顺序需要由3个阶段去保障：

1. 有序发送：消息被发送时保持顺序。对于有顺序要求的消息，用户应该在**同一线程？**中采用同步的方式发送。多线程发送的消息，不同线程的消息不是顺序发布的，同一线程的消息是顺序发布的，这是需要用户自己去保障的。**注意这里是有顺序要求的消息，对于多组有序消息组，可以使用多线程？**。
2. 有序存储：消息被存储在broker时保持和发送的顺序一致，要求同一线程中被发送出来的消息A和B，存储时在空间上A一定在B之前
3. 有序消费：消息被消费时保持和存储的顺序一致

Consumer端

消费者端要保证消息有序，就需要按队列一个一个来取消息，即取完一个队列？



讲讲服务间调用是以怎样的方式实现的?



有没有把定时任务和mq服务拆分出来，如何拆分的？



说说dubbo的流程？



你简历上有提到mvcc，说说mvcc



能讲讲sql优化吗？



有使用过多线程的场景吗？并发容器？线程池？线程池参数？

```java
Runtime.getRuntime().availableProcessors()
```

说说java的并发包 ConcurrentHashMap

java8中

底层数据结构是一个Node的数组